export type Byte = number;
export type Bytes = Byte[];

export type Fragment = Byte | Bytes | Fragment[];

const brand: unique symbol;
type Brand<T, B extends string> = T & { [brand]: B };

export type typeidx = Brand<Bytes, "typeidx">;
export type funcidx = Brand<Bytes, "funcidx">;
export type localidx = Brand<Bytes, "localidx">;
export type globalidx = Brand<Bytes, "globalidx">;
export type tableidx = Brand<Bytes, "tableidx">;
export type labelidx = Brand<Bytes, "labelidx">;
export type memidx = Brand<Bytes, "memidx">;

export function stringToBytes(s: string): Bytes;

export function magic(): Bytes;
export function version(): Bytes;

export function u32(v: number): Bytes;
export function i32(v: number): Bytes;

export function section(id: number, contents: Fragment): Fragment;
export function vec<T extends Fragment>(elements: T[]): Fragment;

// Type section
// ------------

export const SECTION_ID_TYPE: number;

export type valtype = Brand<number, "valtype">;

export const valtype: {
  i32: valtype;
  i64: valtype;
  f32: valtype;
  f64: valtype;
};

export function functype(
  paramTypes: valtype[],
  resultTypes: valtype[],
): Fragment;

export function typesec(functypes: Fragment[]): Fragment;

// Function section and indices
// ----------------------------

export const SECTION_ID_FUNCTION: number;

export function typeidx(x: number): typeidx;
export function funcidx(x: number): funcidx;
export function localidx(x: number): localidx;
export function labelidx(x: number): labelidx;
export function tableidx(x: number): tableidx;
export function globalidx(x: number): globalidx;
export function memidx(x: number): memidx;

export function funcsec(typeidxs: typeidx[]): Fragment;

// Code section
// ------------

export const SECTION_ID_CODE: number;

export function code(func: Fragment): Fragment;

export function func(locals: Fragment[], body: Fragment): Fragment;

export function codesec(codes: Fragment[]): Fragment;

// Instructions etc.
// -----------------

// Autogenerated by scripts/gen_instr_type.js. Do not edit manually.
export const instr: {
  readonly end: 0x0b;
  i32: {
    readonly const: 0x41;
    readonly add: 0x6a;
    readonly sub: 0x6b;
    readonly mul: 0x6c;
    readonly div_s: 0x6d;
    readonly eq: 0x46;
    readonly ne: 0x47;
    readonly lt_s: 0x48;
    readonly lt_u: 0x49;
    readonly gt_s: 0x4a;
    readonly gt_u: 0x4b;
    readonly le_s: 0x4c;
    readonly le_u: 0x4d;
    readonly ge_s: 0x4e;
    readonly ge_u: 0x4f;
    readonly eqz: 0x45;
    readonly and: 0x71;
    readonly or: 0x72;
    readonly load: 0x28;
    readonly store: 0x36;
    readonly load8_s: 0x2c;
    readonly load8_u: 0x2d;
    readonly load16_s: 0x2e;
    readonly load16_u: 0x2f;
    readonly store8: 0x3a;
    readonly store16: 0x3b;
    readonly clz: 0x67;
    readonly ctz: 0x68;
    readonly popcnt: 0x69;
    readonly div_u: 0x6e;
    readonly rem_s: 0x6f;
    readonly rem_u: 0x70;
    readonly xor: 0x73;
    readonly shl: 0x74;
    readonly shr_s: 0x75;
    readonly shr_u: 0x76;
    readonly rotl: 0x77;
    readonly rotr: 0x78;
    readonly wrap_i64: 0xa7;
    readonly trunc_f32_s: 0xa8;
    readonly trunc_f32_u: 0xa9;
    readonly trunc_f64_s: 0xaa;
    readonly trunc_f64_u: 0xab;
    readonly reinterpret_f32: 0xbc;
  };
  i64: {
    readonly const: 0x42;
    readonly load: 0x29;
    readonly load8_s: 0x30;
    readonly load8_u: 0x31;
    readonly load16_s: 0x32;
    readonly load16_u: 0x33;
    readonly load32_s: 0x34;
    readonly load32_u: 0x35;
    readonly store: 0x37;
    readonly store8: 0x3c;
    readonly store16: 0x3d;
    readonly store32: 0x3e;
    readonly eqz: 0x50;
    readonly eq: 0x51;
    readonly ne: 0x52;
    readonly lt_s: 0x53;
    readonly lt_u: 0x54;
    readonly gt_s: 0x55;
    readonly gt_u: 0x56;
    readonly le_s: 0x57;
    readonly le_u: 0x58;
    readonly ge_s: 0x59;
    readonly ge_u: 0x5a;
    readonly clz: 0x79;
    readonly ctz: 0x7a;
    readonly popcnt: 0x7b;
    readonly add: 0x7c;
    readonly sub: 0x7d;
    readonly mul: 0x7e;
    readonly div_s: 0x7f;
    readonly div_u: 0x80;
    readonly rem_s: 0x81;
    readonly rem_u: 0x82;
    readonly and: 0x83;
    readonly or: 0x84;
    readonly xor: 0x85;
    readonly shl: 0x86;
    readonly shr_s: 0x87;
    readonly shr_u: 0x88;
    readonly rotl: 0x89;
    readonly rotr: 0x8a;
    readonly extend_i32_s: 0xac;
    readonly extend_i32_u: 0xad;
    readonly trunc_f32_s: 0xae;
    readonly trunc_f32_u: 0xaf;
    readonly trunc_f64_s: 0xb0;
    readonly trunc_f64_u: 0xb1;
    readonly reinterpret_f64: 0xbd;
  };
  f32: {
    readonly const: 0x43;
    readonly load: 0x2a;
    readonly store: 0x38;
    readonly eq: 0x5b;
    readonly ne: 0x5c;
    readonly lt: 0x5d;
    readonly gt: 0x5e;
    readonly le: 0x5f;
    readonly ge: 0x60;
    readonly abs: 0x8b;
    readonly neg: 0x8c;
    readonly ceil: 0x8d;
    readonly floor: 0x8e;
    readonly trunc: 0x8f;
    readonly nearest: 0x90;
    readonly sqrt: 0x91;
    readonly add: 0x92;
    readonly sub: 0x93;
    readonly mul: 0x94;
    readonly div: 0x95;
    readonly min: 0x96;
    readonly max: 0x97;
    readonly copysign: 0x98;
    readonly convert_i32_s: 0xb2;
    readonly convert_i32_u: 0xb3;
    readonly convert_i64_s: 0xb4;
    readonly convert_i64_u: 0xb5;
    readonly demote_f64: 0xb6;
    readonly reinterpret_i32: 0xbe;
  };
  f64: {
    readonly const: 0x44;
    readonly load: 0x2b;
    readonly store: 0x39;
    readonly eq: 0x61;
    readonly ne: 0x62;
    readonly lt: 0x63;
    readonly gt: 0x64;
    readonly le: 0x65;
    readonly ge: 0x66;
    readonly abs: 0x99;
    readonly neg: 0x9a;
    readonly ceil: 0x9b;
    readonly floor: 0x9c;
    readonly trunc: 0x9d;
    readonly nearest: 0x9e;
    readonly sqrt: 0x9f;
    readonly add: 0xa0;
    readonly sub: 0xa1;
    readonly mul: 0xa2;
    readonly div: 0xa3;
    readonly min: 0xa4;
    readonly max: 0xa5;
    readonly copysign: 0xa6;
    readonly convert_i32_s: 0xb7;
    readonly convert_i32_u: 0xb8;
    readonly convert_i64_s: 0xb9;
    readonly convert_i64_u: 0xba;
    readonly promote_f32: 0xbb;
    readonly reinterpret_i64: 0xbf;
  };
  local: {
    readonly get: 0x20;
    readonly set: 0x21;
    readonly tee: 0x22;
  };
  readonly drop: 0x1a;
  readonly call: 0x10;
  readonly if: 0x04;
  readonly else: 0x05;
  readonly block: 0x02;
  readonly loop: 0x03;
  readonly br: 0x0c;
  readonly br_if: 0x0d;
  memory: {
    readonly size: 0x3f;
    readonly grow: 0x40;
  };
  readonly unreachable: 0x00;
  global: {
    readonly get: 0x23;
    readonly set: 0x24;
  };
  readonly call_indirect: 0x11;
  readonly nop: 0x01;
  readonly br_table: 0x0e;
  readonly return: 0x0f;
  readonly select: 0x1b;
};
// End of autogenerated instruction types.

export const blocktype: { empty: number } & typeof valtype;

// Export section
// --------------

export const SECTION_ID_EXPORT: number;

export function name(s: string): Fragment;

export function export_(nm: string, exportdesc: Fragment): Fragment;

export function exportsec(exports: Fragment[]): Fragment;

export const exportdesc: {
  func(idx: funcidx): Fragment;
  mem(idx: memidx): Fragment;
};

// Module
// ------

export type WasmModule = Fragment[];

export function module(sections: Fragment[]): WasmModule;

// Locals
// ------

export function locals(n: number, type: valtype): Fragment;

// Imports
// -------

export const SECTION_ID_IMPORT: number;

export function import_(mod: string, nm: string, d: Fragment): Fragment;

export function importsec(ims: Fragment[]): Fragment;

export const importdesc: {
  func(x: typeidx): Fragment;
};

// Memory
// ------

export const SECTION_ID_MEMORY: number;

export function memsec(mems: Fragment[]): Fragment;

export function mem(memtype: Fragment): Fragment;

export function memtype(limits: Fragment): Fragment;

export const limits: {
  min(n: number): Fragment;
  minmax(n: number, m: number): Fragment;
};

export function memarg(align: number, offset: number): Fragment;

// Data / custom / names
// ---------------------

export const SECTION_ID_DATA: number;

export function data(x: memidx, e: Fragment, bs: Byte[]): Fragment;

export function datasec(segs: Fragment[]): Fragment;

export const SECTION_ID_CUSTOM: number;

export function custom(nameBytes: Fragment, payload: Fragment): Fragment;
export function customsec(custom: Fragment): Fragment;

export function namesec(namedata: Fragment): Fragment;

export function namedata(
  modulenamesubsec: Fragment,
  funcnamesubsec: Fragment,
  localnamesubsec: Fragment,
): Fragment;

export const CUSTOM_NAME_SUB_SEC_MODULE: number;
export function modulenamesubsec(n: string): Fragment;

export const CUSTOM_NAME_SUB_SEC_FUNC: number;
export function funcnamesubsec(namemap: Fragment): Fragment;

export function namesubsection(N: number, B: Fragment): Fragment;

export function namemap(nameassocs: Fragment[]): Fragment;

export function nameassoc(idx: Fragment, n: string): Fragment;

export const CUSTOM_NAME_SUB_SEC_LOCAL: number;
export function localnamesubsec(indirectnamemap: Fragment): Fragment;

export function indirectnamemap(indirectnameassocs: Fragment[]): Fragment;

export function indirectnameassoc(idx: Fragment, namemap: Fragment): Fragment;

// Start section
// -------------

export const SECTION_ID_START: number;

export const start: (x: number) => funcidx;

export function startsec(st: funcidx): Fragment;

// Globals
// -------

export const SECTION_ID_GLOBAL: number;

export type mut = Brand<number, "mut">;

export const mut: {
  const: mut;
  var: mut;
};

export function globaltype(t: valtype, m: number): Fragment;

export function global(gt: Fragment, e: Fragment): Fragment;

export function globalsec(globs: Fragment[]): Fragment;

// Tables / elements
// -----------------

export const SECTION_ID_TABLE: number;

export const elemtype: {
  funcref: number;
};

export function tabletype(et: number, lim: Fragment): Fragment;

export function table(tt: Fragment): Fragment;

export function tablesec(tables: Fragment[]): Fragment;

export const SECTION_ID_ELEMENT: number;

export function elem(x: tableidx, e: Fragment, ys: funcidx[]): Fragment;

export function elemsec(segs: Fragment[]): Fragment;
